<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Comic Viewer</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#fbfbf8">
  <link rel="icon" href="assets/icon-192.png">

  <!-- Base UI font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Jost:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --paper: #ffffff;
      --ink: #111;
      --line: rgba(0,0,0,0.12);

      --nav-bg: rgba(255,255,255,0.78);
      --nav-border: rgba(0,0,0,0.18);
      --nav-shadow: rgba(0,0,0,0.16);
    }

    /* ✅ Prevent page scroll / bounce */
    html, body {
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
    }

    body {
      margin: 0;
      background: var(--paper);
      color: var(--ink);
      font-family: "Jost", system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    #topbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      background: var(--paper);
      border-bottom: 1px solid var(--line);
      font-size: 14px;

      transition: opacity 160ms ease, transform 160ms ease;
    }
    #topbar .center {
      flex: 1;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0.95;
    }
    #topbar a {
      color: var(--ink);
      text-decoration: none;
      opacity: 0.9;
    }

    /* ===== Viewer ===== */
    #viewer {
      position: relative;
      flex: 1;
      overflow: hidden;

      /* ✅ stop 1-finger panning (prevents wobble), keep 2-finger pinch */
      touch-action: pinch-zoom;

      background: var(--paper);
      display: grid;
      place-items: center;
      padding: 12px 0;
    }

    #panelImg {
      width: min(620px, 94vw);
      height: auto;
      max-height: calc(100vh - 140px);
      object-fit: contain;
      display: block;
      background: transparent;
      -webkit-user-drag: none;

      opacity: 1;
      transform: translateX(0);
      transition: opacity 160ms ease, transform 200ms ease;
      will-change: transform, opacity;
    }
    #panelImg.is-fading { opacity: 0; }

    /* ✅ Story "Blättern" Animation (nur für Comic-Wechsel) */
    #panelImg.story-exit-left  { transform: translateX(-42px); opacity: 0; }
    #panelImg.story-exit-right { transform: translateX( 42px); opacity: 0; }

    #panelImg.story-enter-from-right { transform: translateX(42px); opacity: 0; }
    #panelImg.story-enter-from-left  { transform: translateX(-42px); opacity: 0; }

    .navBtn{
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 1px solid var(--nav-border);
      background: var(--nav-bg);
      box-shadow: 0 8px 20px var(--nav-shadow);
      display: grid;
      place-items: center;
      cursor: pointer;
      z-index: 5;
      padding: 0;
      -webkit-tap-highlight-color: transparent;

      transition: opacity 160ms ease, transform 160ms ease;
    }
    .navBtn:disabled{
      opacity: 0.35;
      cursor: default;
      box-shadow: none;
    }

    .navPrev{ left: 10px; }
    .navNext{ right: 10px; }

    @media (pointer: coarse){
      .navBtn{ width: 46px; height: 46px; }
      .navPrev{ left: 8px; }
      .navNext{ right: 8px; }
    }

    .navBtn svg{
      width: 18px;
      height: 18px;
      display: block;
      fill: none;
      stroke: var(--ink);
      stroke-width: 2.5;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.95;
    }

    #dots {
      position: absolute;
      bottom: 10px;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      pointer-events: auto;
      z-index: 4;

      transition: opacity 160ms ease, transform 160ms ease;
    }

    .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: rgba(0,0,0,0.25);
      cursor: pointer;
    }
    .dot.active {
      background: rgba(0,0,0,0.78);
      transform: scale(1.2);
    }

    #endControls{
      display: none;
      font-family: inherit;
      gap: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.55);
      border-top: 1px solid var(--line);
      backdrop-filter: blur(6px);

      transition: opacity 160ms ease, transform 160ms ease;
    }
    #endControls button{
      flex: 1;
      font-family: inherit;
      font-size: 15px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.18);
      background: rgba(255,255,255,0.85);
      color: var(--ink);
      cursor: pointer;
    }
    #endControls button:disabled{ opacity: 0.45; cursor: default; }

    @media (max-width: 420px) {
      #panelImg { width: min(720px, 96vw); }
      #endControls button{ font-size: 15px; padding: 10px 12px; }
    }

    /* ===== Fokus-Lesemodus (UI ausblenden) ===== */
    body.ui-hidden #topbar {
      opacity: 0;
      transform: translateY(-8px);
      pointer-events: none;
    }

    body.ui-hidden .navBtn {
      opacity: 0;
      pointer-events: none;
      transform: translateY(-50%) scale(0.98);
    }

    /* ✅ Dots bleiben im Fokusmodus sichtbar -> NICHT ausblenden */

    body.ui-hidden #endControls {
      opacity: 0;
      transform: translateY(8px);
      pointer-events: none;
    }

    /* im Fokusmodus mehr Höhe fürs Bild (weil Topbar weg ist) */
    body.ui-hidden #panelImg{
      max-height: calc(100vh - 40px);
    }

    /* ===== Titel-Overlay im Fokusmodus ===== */
    #focusTitle {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;

      max-width: min(92vw, 680px);
      padding: 10px 14px;
      border-radius: 999px;

      background: rgba(255,255,255,0.78);
      border: 1px solid rgba(0,0,0,0.10);
      box-shadow: 0 10px 28px rgba(0,0,0,0.12);
      backdrop-filter: blur(8px);

      color: var(--ink);
      font-family: Futura, "Futura PT", "Jost", system-ui, sans-serif;
      font-weight: 500;
      font-size: 16px;
      letter-spacing: 0.2px;
      line-height: 1.2;
      text-align: center;

      opacity: 0;
      pointer-events: none;
      transition: opacity 180ms ease, transform 180ms ease;
    }

    #focusTitle.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    @media (max-width: 420px) {
      #focusTitle { font-size: 15px; padding: 9px 12px; }
    }

    /* ===== Ende-Hinweis (oben) ===== */
    #endOverlay {
      position: absolute;
      top: 58px;
      left: 50%;
      transform: translateX(-50%) scale(0.98);
      z-index: 12;

      padding: 10px 14px;
      border-radius: 999px;
      max-width: min(92vw, 680px);

      background: rgba(255,255,255,0.82);
      border: 1px solid rgba(0,0,0,0.10);
      box-shadow: 0 14px 40px rgba(0,0,0,0.14);
      backdrop-filter: blur(10px);

      color: var(--ink);
      font-family: Futura, "Futura PT", "Jost", system-ui, sans-serif;
      font-weight: 500;
      font-size: 15px;
      line-height: 1.2;
      text-align: center;

      opacity: 0;
      pointer-events: none;
      transition: opacity 180ms ease, transform 180ms ease;
    }

    #endOverlay.visible {
      opacity: 1;
      transform: translateX(-50%) scale(1);
    }

    @media (max-width: 420px) {
      #endOverlay { font-size: 14px; padding: 9px 12px; top: 54px; }
    }
  </style>
</head>
<body>

  <div id="topbar">
    <a href="library.html">← Auswahl</a>
    <div class="center" id="title">Comic</div>
    <div id="progress">1 / 1</div>
  </div>

  <div id="viewer">
    <!-- Fokus-Titel Overlay -->
    <div id="focusTitle" aria-hidden="true"></div>

    <!-- ✅ Ende-Hinweis (nur beim allerletzten Comic) -->
    <div id="endOverlay" aria-hidden="true">Ende. Nach oben wischen zur Auswahl</div>

    <!-- Left / Right arrows -->
    <button id="navPrev" class="navBtn navPrev" aria-label="Zurück">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M15 18l-6-6 6-6"></path>
      </svg>
    </button>

    <img id="panelImg" src="" alt="Comic Panel">

    <button id="navNext" class="navBtn navNext" aria-label="Weiter">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M9 6l6 6-6 6"></path>
      </svg>
    </button>

    <div id="dots" aria-label="Panel positions"></div>
  </div>

  <!-- Only visible on last panel -->
  <div id="endControls">
    <button id="backToList">Zurück zur Auswahl</button>
    <button id="nextStory">Nächste Geschichte</button>
  </div>

  <script>
    function getComicIdFromUrl() {
      const params = new URLSearchParams(location.search);
      const hashId = location.hash ? decodeURIComponent(location.hash.slice(1)) : "";
      return params.get("id") || hashId || "vus_001";
    }

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.json();
    }

    // DOM
    const progressEl = document.getElementById("progress");
    const viewer = document.getElementById("viewer");
    const titleEl = document.getElementById("title");
    const img = document.getElementById("panelImg");
    const dotsEl = document.getElementById("dots");
    const focusTitleEl = document.getElementById("focusTitle");
    const endOverlayEl = document.getElementById("endOverlay");

    const navPrev = document.getElementById("navPrev");
    const navNext = document.getElementById("navNext");

    const endControls = document.getElementById("endControls");
    const backToListBtn = document.getElementById("backToList");
    const nextStoryBtn = document.getElementById("nextStory");

    // State
    let comicsIndex = [];
    let currentComicId = "";
    let currentComicPath = "";
    let panels = [];
    let totalPanels = 1;
    let currentIndex = 0;

    // Focus UI toggle state
    let uiHidden = false;

    // Auto-hide timer (when UI is temporarily shown)
    let autoHideTimer = null;

    // Title overlay timer
    let focusTitleTimer = null;

    // Preload cache
    const preloadCache = new Map(); // src -> Image

    // ✅ Story transition state
    let storyTransitioning = false;
    let ignoreNextHashChange = false;

    function isZoomed() {
      return !!window.visualViewport && window.visualViewport.scale > 1.01;
    }

    // ===== Ende-Overlay (nur beim allerletzten Comic + letztes Panel) =====
    function hideEndOverlay() {
      endOverlayEl.classList.remove("visible");
    }

    function updateEndOverlay(atEnd) {
      const isLastComic = !getNextComicId();
      const show = atEnd && isLastComic && uiHidden; // nur im Fokusmodus
      endOverlayEl.classList.toggle("visible", show);
    }

    function setUiHidden(hidden) {
      uiHidden = hidden;
      document.body.classList.toggle("ui-hidden", uiHidden);

      if (uiHidden) flashFocusTitle();
      else hideFocusTitle();

      // ✅ Overlay-State neu bewerten (z.B. beim Peek)
      const atEnd = currentIndex === totalPanels - 1;
      updateEndOverlay(atEnd);
    }

    function getNextComicId() {
      const i = comicsIndex.findIndex(c => c.id === currentComicId);
      if (i < 0) return null;
      const next = comicsIndex[i + 1];
      return next ? next.id : null;
    }

    function getPrevComicId() {
      const i = comicsIndex.findIndex(c => c.id === currentComicId);
      if (i <= 0) return null;
      const prev = comicsIndex[i - 1];
      return prev ? prev.id : null;
    }

    function goToList() {
      window.location.href = "library.html";
    }

    function fileAt(i) {
      return panels[i] || "000.webp";
    }

    function currentPanelSrc(i) {
      return currentComicPath + fileAt(i);
    }

    function clearAutoHide() {
      if (autoHideTimer) {
        clearTimeout(autoHideTimer);
        autoHideTimer = null;
      }
    }

    function setSrcWithFade(newSrc) {
      // ✅ Panels: Fade
      img.classList.add("is-fading");
      setTimeout(() => { img.src = newSrc; }, 120);
      img.onload = () => img.classList.remove("is-fading");
    }

    function setSrcImmediate(newSrc) {
      // ✅ Für Story-Wechsel: ohne Fade, damit Slide sauber aussieht
      img.classList.remove("is-fading");
      img.src = newSrc;
    }

    function renderDots() {
      dotsEl.innerHTML = "";
      for (let i = 0; i < totalPanels; i++) {
        const d = document.createElement("div");
        d.className = "dot" + (i === currentIndex ? " active" : "");
        d.addEventListener("click", () => {
          hideFocusTitle();
          hideEndOverlay();
          goTo(i);
        });
        dotsEl.appendChild(d);
      }
    }

    function updateDots() {
      const dots = dotsEl.children;
      for (let i = 0; i < dots.length; i++) {
        dots[i].classList.toggle("active", i === currentIndex);
      }
    }

    function updateUI() {
      progressEl.textContent = `${currentIndex + 1} / ${totalPanels}`;

      const atStart = currentIndex === 0;
      const atEnd = currentIndex === totalPanels - 1;

      navPrev.disabled = atStart;
      navNext.disabled = atEnd;

      endControls.style.display = atEnd ? "flex" : "none";
      nextStoryBtn.style.display = (atEnd && !!getNextComicId()) ? "" : "none";

      updateDots();

      // ✅ Ende-Hinweis: nur beim letzten Comic + letztes Panel (und Fokusmodus)
      updateEndOverlay(atEnd);
    }

    // ===== Fokus-Titel Overlay =====
    function hideFocusTitle() {
      if (focusTitleTimer) {
        clearTimeout(focusTitleTimer);
        focusTitleTimer = null;
      }
      focusTitleEl.classList.remove("visible");
    }

    function flashFocusTitle() {
      if (!uiHidden) return;

      const t = (titleEl.textContent || "").trim();
      if (!t) return;

      focusTitleEl.textContent = t;
      focusTitleEl.classList.add("visible");

      if (focusTitleTimer) clearTimeout(focusTitleTimer);
      focusTitleTimer = setTimeout(() => {
        focusTitleEl.classList.remove("visible");
        focusTitleTimer = null;
      }, 2500);
    }

    // ===== Auto-hide UI (peek) =====
    function peekUiOrToggle() {
      hideFocusTitle();
      hideEndOverlay();

      if (uiHidden) {
        setUiHidden(false);
        clearAutoHide();
        autoHideTimer = setTimeout(() => {
          setUiHidden(true);
          autoHideTimer = null;
        }, 2000);
      } else {
        clearAutoHide();
        setUiHidden(true);
      }
    }

    function setImage() {
      const src = currentPanelSrc(currentIndex);
      setSrcWithFade(src);
      updateUI();

      // ✅ Preloading is here:
      preloadAround(currentIndex);
    }

    function goTo(i) {
      if (i < 0 || i >= totalPanels) return;
      currentIndex = i;

      hideFocusTitle();
      hideEndOverlay();

      setImage();
    }

    // ===== Panels / Story nav helpers =====
    function prevPanelOrStory() {
      const atStart = currentIndex === 0;
      if (!atStart) return goTo(currentIndex - 1);

      const prevId = getPrevComicId();
      if (prevId) transitionToStory(prevId, "prev");
    }

    function nextPanelOrStory() {
      const atEnd = currentIndex === totalPanels - 1;
      if (!atEnd) return goTo(currentIndex + 1);

      const nextId = getNextComicId();
      if (nextId) transitionToStory(nextId, "next");
    }

    // ===== Story "Blättern" Animation =====
    function clearStoryClasses() {
      img.classList.remove(
        "story-exit-left", "story-exit-right",
        "story-enter-from-left", "story-enter-from-right"
      );
    }

    async function transitionToStory(targetId, dir /* "next" | "prev" */) {
      if (storyTransitioning) return;
      storyTransitioning = true;

      hideFocusTitle();
      hideEndOverlay();
      clearAutoHide();
      setUiHidden(true);

      const exitClass = (dir === "next") ? "story-exit-left" : "story-exit-right";
      const enterFromClass = (dir === "next") ? "story-enter-from-right" : "story-enter-from-left";

      clearStoryClasses();
      requestAnimationFrame(() => {
        img.classList.add(exitClass);
      });

      const exitDelay = 200;
      setTimeout(async () => {
        try {
          ignoreNextHashChange = true;
          location.hash = encodeURIComponent(targetId);

          clearStoryClasses();
          img.classList.add(enterFromClass);

          await loadComic(targetId, { useImmediateImage: true });

          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              img.classList.remove(enterFromClass);
            });
          });

          setTimeout(() => {
            storyTransitioning = false;
          }, 230);

        } catch (err) {
          console.error(err);
          storyTransitioning = false;
        }
      }, exitDelay);
    }

    // ===== Preloading =====
    function preloadSrc(src) {
      if (!src) return;
      if (preloadCache.has(src)) return;

      const im = new Image();
      im.decoding = "async";
      im.loading = "eager";
      im.src = src;

      preloadCache.set(src, im);

      if (preloadCache.size > 60) {
        const firstKey = preloadCache.keys().next().value;
        preloadCache.delete(firstKey);
      }
    }

    function preloadAround(idx) {
      const candidates = [
        idx - 2, idx - 1,
        idx + 1, idx + 2,
      ].filter(i => i >= 0 && i < totalPanels);

      for (const i of candidates) {
        preloadSrc(currentPanelSrc(i));
      }

      const atStart = idx === 0;
      const atEnd = idx === totalPanels - 1;

      if (atEnd) {
        const nextId = getNextComicId();
        if (nextId) preloadSrc(`comics/${nextId}/000.webp`);
      }
      if (atStart) {
        const prevId = getPrevComicId();
        if (prevId) preloadSrc(`comics/${prevId}/000.webp`);
      }
    }

    // ===== Buttons =====
    navPrev.addEventListener("click", () => {
      hideFocusTitle();
      hideEndOverlay();
      prevPanelOrStory();
    });

    navNext.addEventListener("click", () => {
      hideFocusTitle();
      hideEndOverlay();
      nextPanelOrStory();
    });

    backToListBtn.addEventListener("click", goToList);

    nextStoryBtn.addEventListener("click", () => {
      const nextId = getNextComicId();
      if (!nextId) return;
      transitionToStory(nextId, "next");
    });

    // Keyboard
    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft")  { hideFocusTitle(); hideEndOverlay(); prevPanelOrStory(); }
      if (e.key === "ArrowRight") { hideFocusTitle(); hideEndOverlay(); nextPanelOrStory(); }
      if (e.key === "Escape") goToList();
      if (e.key === " " || e.key === "Enter") peekUiOrToggle();
    });

    // ===== Tap-to-toggle UI (Focus "peek" mode) + ✅ Tap-Zonen links/rechts =====
    function isInteractiveTarget(el) {
      if (!el) return false;
      return !!el.closest("button, a, #dots, .dot, #endControls");
    }

    viewer.addEventListener("click", (e) => {
      if (isInteractiveTarget(e.target)) return;

      const rect = viewer.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const w = rect.width;

      const edgeZone = Math.max(64, w * 0.18);

      if (x <= edgeZone) {
        prevPanelOrStory();
        return;
      }
      if (x >= (w - edgeZone)) {
        nextPanelOrStory();
        return;
      }

      peekUiOrToggle();
    });

    // ✅ Prevent 1-finger scroll rubber-band wobble (keep pinch zoom)
    viewer.addEventListener("touchmove", (e) => {
      if (e.touches.length === 1 && !isZoomed()) {
        e.preventDefault();
      }
    }, { passive: false });

    // ===== Swipe (Panels + Storywechsel + Swipe up = zurück) + ✅ Edge-Swipe =====
    let startX = 0;
    let startY = 0;
    let startEdge = false;

    viewer.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      if (isZoomed()) return;

      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;

      const edgePx = Math.min(28, window.innerWidth * 0.06);
      startEdge = (startX <= edgePx);
    }, { passive: true });

    viewer.addEventListener("touchend", (e) => {
      if (!startX || !startY) return;

      const touch = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
      if (!touch) return;

      const endX = touch.clientX;
      const endY = touch.clientY;

      const dx = endX - startX;
      const dy = endY - startY;

      const wasEdge = startEdge;

      startX = 0;
      startY = 0;
      startEdge = false;

      const thresholdX = Math.min(80, window.innerWidth * 0.12);
      const thresholdY = Math.min(120, window.innerHeight * 0.16);

      // ✅ Edge-Swipe (links -> rechts): zurück zur Auswahl
      if (wasEdge && dx > thresholdX && Math.abs(dx) > Math.abs(dy)) {
        goToList();
        return;
      }

      if (Math.abs(dx) > Math.abs(dy)) {
        hideFocusTitle();
        hideEndOverlay();

        if (dx < -thresholdX) {
          nextPanelOrStory();
        } else if (dx > thresholdX) {
          prevPanelOrStory();
        }
        return;
      }

      if (dy < -thresholdY) {
        goToList();
      }
    }, { passive: true });

    // Hash change (external navigation)
    window.addEventListener("hashchange", () => {
      if (ignoreNextHashChange) {
        ignoreNextHashChange = false;
        return;
      }
      const newId = getComicIdFromUrl();
      loadComic(newId).catch(err => {
        console.error(err);
        titleEl.textContent = "Fehler";
        progressEl.textContent = "—";
      });
    });

    async function loadComic(comicId, opts = {}) {
      currentComicId = comicId;
      currentComicPath = `comics/${currentComicId}/`;

      const data = await fetchJson(currentComicPath + "comic.json");

      titleEl.textContent = data.title || currentComicId;
      panels = Array.isArray(data.panels) ? data.panels : [];
      totalPanels = panels.length || 1;

      currentIndex = 0;

      renderDots();

      // ✅ Fokusmodus startet sofort beim Öffnen / Storywechsel
      setUiHidden(true);

      const firstSrc = currentPanelSrc(0);
      if (opts.useImmediateImage) setSrcImmediate(firstSrc);
      else setSrcWithFade(firstSrc);

      updateUI();

      preloadAround(0);

      flashFocusTitle();

      // Ende-Hinweis sicher aus (Index=0)
      updateEndOverlay(currentIndex === totalPanels - 1);
    }

    async function init() {
      comicsIndex = await fetchJson("comics/index.json");
      await loadComic(getComicIdFromUrl());
    }

    init().catch(err => {
      console.error(err);
      titleEl.textContent = "Fehler";
      progressEl.textContent = "—";
    });

    // Service Worker (disable on localhost for easier development)
    if ("serviceWorker" in navigator && location.hostname !== "localhost") {
      navigator.serviceWorker.register("sw.js").catch(console.error);
    }
  </script>

</body>
</html>
