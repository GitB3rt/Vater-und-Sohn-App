<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Comic Viewer</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#fbfbf8">
  <link rel="icon" href="assets/icon-192.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Jost:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root{
      /* One single "paper white" for EVERYTHING */
      --paper: #ffffff;       /* slightly warm, brighter than before */
      --ink: #111;
      --line: rgba(0,0,0,0.12);
      --shadow: rgba(0,0,0,0.10);

      /* Nav buttons */
      --nav-bg: rgba(255,255,255,0.78);
      --nav-border: rgba(0,0,0,0.18);
      --nav-shadow: rgba(0,0,0,0.16);
    }

    body {
      margin: 0;
      background: var(--paper);
      color: var(--ink);
      font-family: "Jost", system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    #topbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      background: var(--paper);
      border-bottom: 1px solid var(--line);
      font-size: 14px;
    }
    #topbar .center {
      flex: 1;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0.95;
    }
    #topbar a {
      color: var(--ink);
      text-decoration: none;
      opacity: 0.9;
    }

    /* ===== Viewer ===== */
    #viewer {
      position: relative;
      flex: 1;
      overflow: hidden;
      touch-action: pan-y pinch-zoom;
      background: var(--paper);
      display: grid;
      place-items: center;
      padding: 12px 0;
    }

    /* Single panel image — no box, no different whites */
    #panelImg {
      width: min(620px, 94vw);                 /* slightly larger */
      height: auto;
      max-height: calc(100vh - 140px);         /* leave room for topbar + dots + end controls */
      object-fit: contain;
      display: block;
      background: transparent;                /* EXACT SAME as page */
      -webkit-user-drag: none;

      opacity: 1;
      transition: opacity 160ms ease;
    }
    #panelImg.is-fading { opacity: 0; }

    /* Overlay nav arrows (left/right) */
    .navBtn{
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 1px solid var(--nav-border);
      background: var(--nav-bg);
      box-shadow: 0 8px 20px var(--nav-shadow);
      display: grid;
      place-items: center;
      cursor: pointer;
      z-index: 5;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }
    .navBtn:disabled{
      opacity: 0.35;
      cursor: default;
      box-shadow: none;
    }

    .navPrev{ left: 10px; }
    .navNext{ right: 10px; }

    /* Make buttons easier to hit on touch */
    @media (pointer: coarse){
      .navBtn{ width: 46px; height: 46px; }
      .navPrev{ left: 8px; }
      .navNext{ right: 8px; }
    }

    /* Simple inline SVG arrow sizing */
    .navBtn svg{
      width: 18px;
      height: 18px;
      display: block;
      fill: none;
      stroke: var(--ink);
      stroke-width: 2.5;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.95;
    }

    /* Dots */
    #dots {
      position: absolute;
      bottom: 10px;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      pointer-events: auto;
      z-index: 4;
    }

    .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: rgba(0,0,0,0.25);
      cursor: pointer;
    }
    .dot.active {
      background: rgba(0,0,0,0.78);
      transform: scale(1.2);
    }

    /* End controls (only last panel) */
    #endControls{
      display: none;
      font-family: inherit;
      gap: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.55);
      border-top: 1px solid var(--line);
      backdrop-filter: blur(6px);
    }
    #endControls button{
      flex: 1;
      font-family: inherit;
      font-size: 15px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.18);
      background: rgba(255,255,255,0.85);
      color: var(--ink);
      cursor: pointer;
    }
    #endControls button:disabled{ opacity: 0.45; cursor: default; }

    @media (max-width: 420px) {
      #panelImg { width: min(720px, 96vw); }
      #endControls button{ font-size: 15px; padding: 10px 12px; }
    }
  </style>
</head>
<body>

  <div id="topbar">
    <a href="library.html">← Auswahl</a>
    <div class="center" id="title">Comic</div>
    <div id="progress">1 / 1</div>
  </div>

  <div id="viewer">
    <!-- Left / Right arrows -->
    <button id="navPrev" class="navBtn navPrev" aria-label="Zurück">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M15 18l-6-6 6-6"></path>
      </svg>
    </button>

    <img id="panelImg" src="" alt="Comic Panel">

    <button id="navNext" class="navBtn navNext" aria-label="Weiter">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M9 6l6 6-6 6"></path>
      </svg>
    </button>

    <div id="dots" aria-label="Panel positions"></div>
  </div>

  <!-- Only visible on last panel -->
  <div id="endControls">
    <button id="backToList">Zurück zur Auswahl</button>
    <button id="nextStory">Zur nächsten Geschichte ▶</button>
  </div>

  <script>
    function getComicIdFromUrl() {
      const params = new URLSearchParams(location.search);
      const hashId = location.hash ? decodeURIComponent(location.hash.slice(1)) : "";
      return params.get("id") || hashId || "vus_001";
    }

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.json();
    }

    // DOM
    const progressEl = document.getElementById("progress");
    const viewer = document.getElementById("viewer");
    const titleEl = document.getElementById("title");
    const img = document.getElementById("panelImg");
    const dotsEl = document.getElementById("dots");

    const navPrev = document.getElementById("navPrev");
    const navNext = document.getElementById("navNext");

    const endControls = document.getElementById("endControls");
    const backToListBtn = document.getElementById("backToList");
    const nextStoryBtn = document.getElementById("nextStory");

    // State
    let comicsIndex = [];
    let currentComicId = "";
    let currentComicPath = "";
    let panels = [];
    let totalPanels = 1;
    let currentIndex = 0;

    function isZoomed() {
      return !!window.visualViewport && window.visualViewport.scale > 1.01;
    }

    function getNextComicId() {
      const i = comicsIndex.findIndex(c => c.id === currentComicId);
      if (i < 0) return null;
      const next = comicsIndex[i + 1];
      return next ? next.id : null;
    }

    function goToList() {
      window.location.href = "library.html";
    }

    function goToNextStory() {
      const nextId = getNextComicId();
      if (!nextId) return;
      location.hash = encodeURIComponent(nextId);
    }

    function fileAt(i) {
      return panels[i] || "000.webp";
    }

    function setSrcWithFade(newSrc) {
      img.classList.add("is-fading");
      setTimeout(() => { img.src = newSrc; }, 120);
      img.onload = () => img.classList.remove("is-fading");
    }

    function renderDots() {
      dotsEl.innerHTML = "";
      for (let i = 0; i < totalPanels; i++) {
        const d = document.createElement("div");
        d.className = "dot" + (i === currentIndex ? " active" : "");
        d.addEventListener("click", () => goTo(i));
        dotsEl.appendChild(d);
      }
    }

    function updateDots() {
      const dots = dotsEl.children;
      for (let i = 0; i < dots.length; i++) {
        dots[i].classList.toggle("active", i === currentIndex);
      }
    }

    function updateUI() {
      progressEl.textContent = `${currentIndex + 1} / ${totalPanels}`;

      const atStart = currentIndex === 0;
      const atEnd = currentIndex === totalPanels - 1;

      navPrev.disabled = atStart;
      navNext.disabled = atEnd;

      // Show end controls ONLY at end
      endControls.style.display = atEnd ? "flex" : "none";

      // Only show "next story" if it exists
      nextStoryBtn.style.display = (atEnd && !!getNextComicId()) ? "" : "none";

      updateDots();
    }

    function setImage() {
      const src = currentComicPath + fileAt(currentIndex);
      setSrcWithFade(src);
      updateUI();
    }

    function goTo(i) {
      if (i < 0 || i >= totalPanels) return;
      currentIndex = i;
      setImage();
    }

    function prev() {
      if (currentIndex === 0) return;
      goTo(currentIndex - 1);
    }

    function next() {
      if (currentIndex >= totalPanels - 1) return;
      goTo(currentIndex + 1);
    }

    // Buttons
    navPrev.addEventListener("click", prev);
    navNext.addEventListener("click", next);
    backToListBtn.addEventListener("click", goToList);
    nextStoryBtn.addEventListener("click", goToNextStory);

    // Keyboard
    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") prev();
      if (e.key === "ArrowRight") next();
    });

    // Swipe (no dragging transform; better on mobile)
    let startX = 0;

    viewer.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      if (isZoomed()) return;
      startX = e.touches[0].clientX;
    }, { passive: true });

    viewer.addEventListener("touchend", (e) => {
      if (!startX) return;
      const endX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : startX;
      const dx = endX - startX;
      startX = 0;

      const threshold = Math.min(80, window.innerWidth * 0.12);
      if (dx < -threshold) next();
      else if (dx > threshold) prev();
    }, { passive: true });

    // Hash change (next story)
    window.addEventListener("hashchange", () => {
      const newId = getComicIdFromUrl();
      loadComic(newId).catch(err => {
        console.error(err);
        titleEl.textContent = "Fehler";
        progressEl.textContent = "—";
      });
    });

    async function loadComic(comicId) {
      currentComicId = comicId;
      currentComicPath = `comics/${currentComicId}/`;

      const data = await fetchJson(currentComicPath + "comic.json");

      titleEl.textContent = data.title || currentComicId;
      panels = Array.isArray(data.panels) ? data.panels : [];
      totalPanels = panels.length || 1;

      currentIndex = 0;

      renderDots();
      setImage();
    }

    async function init() {
      comicsIndex = await fetchJson("comics/index.json");
      await loadComic(getComicIdFromUrl());
    }

    init().catch(err => {
      console.error(err);
      titleEl.textContent = "Fehler";
      progressEl.textContent = "—";
    });

    // Service Worker (disable on localhost for easier development)
    if ("serviceWorker" in navigator && location.hostname !== "localhost") {
      navigator.serviceWorker.register("sw.js").catch(console.error);
    }
  </script>

</body>
</html>
